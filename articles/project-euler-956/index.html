<!DOCTYPE html>
<html>
    <head>
        <title>chirprush - Project Euler: Problem 956</title>

        <link rel="stylesheet" href="/assets/css/style.css">
        <link rel="stylesheet" href="/assets/css/panel.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Katex -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

        
        <meta charset="utf-8">
    </head>

    <body>
        <div id="side-nav" class="side-panel">
            <div class="panel-content">
                <div class="panel-grid">
                    <img class="grid-pfp" src="/assets/images/pfp.svg"></img>
                    <h2 class="grid-title">Rushil Surti</h1>
                    <p class="grid-email">rush040507@gmail.com</p>
                    <div class="grid-icons"><a href="https://www.github.com/chirprush/" target="_blank"><i class="fa-brands fa-github"></i></a> <a href="https://www.youtube.com/channel/UCSc-MTo8KGPDMLszD6jYjxA" target="_blank"><i class="fa-brands fa-youtube"></i></a> <a href="https://www.instagram.com/chirprush/" target="_blank"><i class="fa-brands fa-instagram"></i></a> <a href="https://math.stackexchange.com/users/1128617/chirpyboat73" target="_blank"><i class="fa-brands fa-stack-exchange"></i></a></div>
                </div>

                <hr class="separator" />

                <div class="description">
                    <h2>Description</h2>
                    <div class="side-line">
                        <p><p>Solving Project Euler Problem 956 in a
little bit of an overkill way. Stick around for some fast Fourier
transforms over finite fields!</p></p>
                    </div>
                </div>

                <div class="contents">
                    <h2>Contents</h2>
                    <div class="side-line">
                        <ul>
                        <li><a href="#let-me-break-it-down-for-you"
                        id="toc-let-me-break-it-down-for-you">Let Me
                        Break it Down For You</a></li>
                        <li><a
                        href="#hints-of-convolution-and-slight-overkill"
                        id="toc-hints-of-convolution-and-slight-overkill">Hints
                        of Convolution and Slight Overkill</a></li>
                        <li><a href="#the-algorithm"
                        id="toc-the-algorithm">The Algorithm</a></li>
                        <li><a
                        href="#the-fast-number-theoretic-transform"
                        id="toc-the-fast-number-theoretic-transform">The
                        (Fast) Number-Theoretic Transform</a></li>
                        <li><a href="#conclusions"
                        id="toc-conclusions">Conclusions</a></li>
                        </ul>
                        <!--
                        <ul>
                            <li><b>Section 1.</b> Sample text</li>
                            <li><ul>
                                <li><b>Section 1.1.</b> Some stuff</li>
                            </ul></li>
                            <li><b>Section 2.</b> More sample text</li>
                        </ul>
                        -->
                    </div>
                </div>

                <div class="navigation-container">
                    <a href="/index.html">Articles</a>
                    <a href="/tags.html">Tags</a>
                    <a href="/about.html">About Me</a>
                </div>
            </div>
        </div>

        <div class="content-wrapper">
            <div class="content">
                <h1>Project Euler: Problem 956</h1>

                <hr class="separator" />
                <div class="info-holder">
                    <span class="info-value"><b>Author:</b> Rushil Surti</span>
                    <span class="info-value"><b>Date:</b> October 15,
2025</span>
                    <span class="info-value"><b>Tags:</b>  <a href="/tags.html#project-euler"><span class="info-tag">project-euler</span></a>  <a href="/tags.html#number-theory"><span class="info-tag">number-theory</span></a>  <a href="/tags.html#fft"><span class="info-tag">fft</span></a>  <a href="/tags.html#finite-fields"><span class="info-tag">finite-fields</span></a>  <a href="/tags.html#roots-of-unity"><span class="info-tag">roots-of-unity</span></a> </span>
                    <span class="info-value"><b>Edited:</b> October 15,
2025</span>
                </div>

                <p>Hey, everyone! It's been quite a while hasn't it!
                What with the summer and college work starting, I
                decided to put off blogging for a bit, and then that bit
                eventually became quite a while (oops!). Although I
                haven't been blogging for these past several months, the
                actual math work has still been going on behind the
                scenes (some of the homework sets at college do tend to
                slow down the process, but that's for a different
                article perhaps). I've been missing the process of
                writing and what it can do for the both of us, so I hope
                you're just as ready as I am to see some articles on
                elliptic curves, number theoretic sum acceleration, and
                more. Until then, you'll have to wait. It's time to go
                back to where the writing all started: Project
                Euler.</p>
                <div class="black-box">
                <p><strong>Problem.</strong> Let <span
                class="math inline">\(\Omega(n)\)</span> denote the
                number of prime factors (with multiplicity) of <span
                class="math inline">\(n\)</span>. Define <span
                class="math inline">\(D(n, m)\)</span> to be the sum of
                all divisors <span class="math inline">\(d\)</span> of
                <span class="math inline">\(n\)</span> where <span
                class="math inline">\(\Omega(d)\)</span> is divisible by
                <span class="math inline">\(m\)</span>.</p>
                <p>Further, denote by <span
                class="math inline">\(n\$\)</span> the product <span
                class="math display">\[
                    n \$ = 1! \times 2! \times \cdots \times n!
                ,\]</span> and denote by <span
                class="math inline">\(n\bigstar\)</span> the product
                <span class="math display">\[
                    n \bigstar = 1\$ \times 2\$ \times \cdots \times n
                \$
                .\]</span> Find <span class="math inline">\(D(1\, 000
                \bigstar, 1\, 000)\)</span> modulo <span
                class="math inline">\(999\, 999\, 001\)</span>.</p>
                </div>
                <h2 id="let-me-break-it-down-for-you">Let Me Break it
                Down For You</h2>
                <p>Apologies for the bad heading joke. I just had to.
                For convenience, denote <span class="math inline">\(N :=
                1000, K := 1000, M := 999999001\)</span> so that we wish
                to find <span class="math inline">\(D(N \bigstar,
                K)\)</span> modulo <span
                class="math inline">\(M\)</span>.</p>
                <p>One process that helps when breaking down more
                difficult problems is making natural, incremental steps
                towards a goal and seeing where it leads us. One natural
                step would be to assume we can find some prime
                factorization of <span class="math inline">\(N
                \bigstar\)</span>. This assumption then breaks the
                problem into two smaller pieces</p>
                <ol type="1">
                <li>Computing a prime factorization for <span
                class="math inline">\(N \bigstar\)</span></li>
                <li>Finding <span class="math inline">\(D(n, m)\)</span>
                when we know the prime factorization of <span
                class="math inline">\(n\)</span>.</li>
                </ol>
                <p>While these two pieces are still not immediately
                trivial, this is still a useful mental framework for not
                getting a headache and actually solving the problem (two
                things I like achieving!).</p>
                <p>I want to convince you that step
                (<strong>1.</strong>) is not so bad (where we take "bad"
                to be in the sense of time complexity). Indeed, there
                are <span class="math inline">\(O(N / \log N)\)</span>
                primes up to <span class="math inline">\(N\)</span>, and
                we can compute them using a sieve in around <span
                class="math inline">\(O(N \log N)\)</span> time. Then,
                we can compute the factorization (stored as a
                dictionary) for each <span
                class="math inline">\(i!\)</span> for <span
                class="math inline">\(1 \le i \le n\)</span>. Observe
                that we can use this list of factorizations to produce a
                list of factorizations for <span class="math inline">\(i
                \$\)</span> for <span class="math inline">\(1 \le i \le
                n\)</span>: the factorization of <span
                class="math inline">\(i\$\)</span> is the prefix sum
                (where we sum the exponents of each prime) of the
                factorial factorizations. The computation for <span
                class="math inline">\(i\bigstar\)</span> follows the
                same pattern (it is a prefix sum over each <span
                class="math inline">\(i\$\)</span>). We can compute this
                in <span class="math inline">\(O(N^2 / \log N)\)</span>
                time, which is plenty good.</p>
                <p>Now that we're armed with some prime factorization
                from part (<strong>1.</strong>), we can write <span
                class="math inline">\(N \bigstar = p_1^{e_1} p_2^{e_2}
                \cdots p_\ell^{e_\ell}\)</span>. Let's look at part
                (<strong>2.</strong>) (i.e. the rest of the problem). We
                wish to determine some simplified expression for <span
                class="math inline">\(D(p_1^{e_1} p_2^{e_2} \cdots
                p_\ell^{e_\ell}, K)\)</span>. One could imagine trying
                to directly sum over all vectors of exponents that have
                sum divisible by <span class="math inline">\(K\)</span>,
                but it doesn't really seem amenable to any fast methods.
                Although not giving us an immediate solution, this is
                good, because we know that we're being steered in some
                other direction.</p>
                <p>So, what shall we do when we're looking for ideas?
                Play around! I won't calculate explicit numerical
                examples here (if you want to get a better understanding
                of the function I might recommend you do), but we can
                start with some very simple cases. What is <span
                class="math inline">\(D(p^e, K)\)</span>? Well, <span
                class="math inline">\(\Omega(p^e) = e\)</span> for any
                such prime power, so <span class="math inline">\(D(p^e,
                K) = 1 + p^K + \cdots + p^{cK}\)</span> (you can quickly
                evaluate this with a geometric series!), where you can
                imagine that the last prime power exponent is the
                greatest one that is less than <span
                class="math inline">\(e\)</span> (if you want to be
                specific, <span class="math inline">\(c = \lfloor e / K
                \rfloor\)</span>). In particular, for the case of <span
                class="math inline">\(e &lt; K\)</span>, <span
                class="math inline">\(D(p^e, K)\)</span> is just <span
                class="math inline">\(1\)</span>.</p>
                <p>We roughly know the answer for prime powers, so what
                could we do to stitch them together? Let's try finding
                some recursion/multiplicative property of <span
                class="math inline">\(D\)</span>. For this, we'll have
                to make a small leap. Instead of only caring about one
                residue class modulo <span
                class="math inline">\(K\)</span> (i.e. caring about the
                prime factor counts divisible by <span
                class="math inline">\(K\)</span>), we'll have to take
                into account all residue classes. Let <span
                class="math inline">\(D(n, m, r)\)</span> denote the sum
                of the divisiors <span class="math inline">\(d\)</span>
                of <span class="math inline">\(n\)</span> such that
                <span class="math inline">\(\Omega(d) \equiv r
                \pmod{m}\)</span> (for a conceptual link, observe that
                <span class="math inline">\(D(n, m, 0) = D(n,
                m)\)</span>). Now, observe the following <span
                class="math display">\[
                    D(n p^e, K, r) = \sum_{i = 0}^{e} p^i D(n, K, (r -
                i) \bmod{K})
                ,\]</span> where <span class="math inline">\(n\)</span>
                is coprime to <span class="math inline">\(p^e\)</span>
                (notice that we aren't doing individual primes but
                rather prime powers; if you worked out some examples,
                you've seen that if the two numbers aren't coprime then
                you run into some misleading double counting. Try it!).
                This might look like a bunch of symbols on the screen,
                but it encodes a very natural intuition. Since <span
                class="math inline">\(D\)</span> sums over factors of
                <span class="math inline">\(n p^e\)</span>, let's call
                this factor <span class="math inline">\(d\)</span>, then
                <span class="math inline">\(d\)</span> has some power
                (not necessarily positive) of <span
                class="math inline">\(p\)</span> inside it. We can go
                casewise on this power, call it <span
                class="math inline">\(i\)</span>. Since <span
                class="math inline">\(p^i \mid d\)</span>, we can
                definitely multiply it in the sum. Now, we must consider
                what factors of <span class="math inline">\(n\)</span>
                divide <span class="math inline">\(d\)</span>. Since
                <span class="math inline">\(p^i\)</span> has <span
                class="math inline">\(i\)</span> prime factors, we want
                the rest of <span class="math inline">\(d\)</span> to
                have <span class="math inline">\((r - i)
                \bmod{K}\)</span> prime factors to compensate. Summing
                over all cases gives us the above formula!</p>
                <p>The existence of this formula smells like some DP
                (apply the recursive formula to build up each prime
                factor until you have <span class="math inline">\(N
                \bigstar\)</span>), but let's work out some time
                complexities before we commit to this algorithm. At each
                stage, we need to compute <span
                class="math inline">\(K\)</span> values, each <span
                class="math inline">\(D(n, K, r)\)</span> for <span
                class="math inline">\(0 \le r &lt; K\)</span>. Computing
                this takes <span class="math inline">\(e_i\)</span>
                additions (not to mention any other modular arithmetic
                operations since we want the answer modulo <span
                class="math inline">\(M\)</span>, but pretend these
                don't exist for now). Thus, the time complexity would be
                something like <span class="math inline">\(O((e_1 + e_2
                + \cdots + e_\ell)K)\)</span>. This is definitely a
                problem. Since <span class="math inline">\(\nu_p (n!) =
                O(n)\)</span>, we can imagine that <span
                class="math inline">\(\nu_p(n \$) = O(n^2)\)</span> and
                thus <span class="math inline">\(\nu_p(n \bigstar) =
                O(n^3)\)</span> by prefix sums. Since there are <span
                class="math inline">\(O(N / \log N)\)</span> primes up
                to <span class="math inline">\(N\)</span>, this looks
                roughly like <span class="math inline">\(O(N^4 K / \log
                N)\)</span>, which is definitely not happening.</p>
                <p>We need some speedups!</p>
                <h2 id="hints-of-convolution-and-slight-overkill">Hints
                of Convolution and Slight Overkill</h2>
                <p>Let's remind ourselves that we're working modulo
                <span class="math inline">\(M\)</span> (<span
                class="math inline">\(M\)</span> is prime if you haven't
                already checked). When I first saw the summation above,
                my first instinct was a convolution. Indeed, <span
                class="math inline">\(D(np^e, K, r)\)</span> is the
                convolution (with indices modulo <span
                class="math inline">\(K\)</span>) of <span
                class="math inline">\(D(p^e, K, r)\)</span> and <span
                class="math inline">\(D(n, K, r)\)</span> (where all of
                these are treated as arrays indexed by <span
                class="math inline">\(r\)</span>).</p>
                <p>Another quick observation is that since <span
                class="math inline">\(K \mid M - 1\)</span>, we can some
                find <span class="math inline">\(K\)</span>th root of
                unity <span class="math inline">\(\omega\)</span> modulo
                <span class="math inline">\(M\)</span>. This opens up a
                lot of interesting ideas. Unfortunately, and
                fortunately, I was thinking about cyclotomic integers at
                the time, so I missed some other cool, less technical
                solutions.</p>
                <p>The big observation is that, upon seeing this
                convolution, we can think about polynomials instead of
                just plain old arrays of numbers. Indeed, suppose we
                wish to find <span class="math inline">\(D(p_1^{e_1}
                p_2^{e_2} \cdots p_\ell^{e_\ell}, K, r)\)</span> for any
                <span class="math inline">\(0 \le r &lt; K\)</span>.
                Then, consider the polynomial <span
                class="math display">\[
                    f(X) = (1 + p_1 X + \cdots + p_1^{e_1} X^{e_1})
                \cdots (1 + p_\ell X + \cdots + p_\ell^{e_\ell}
                X^{e_\ell})
                .\]</span> The sum of the terms of the coefficients in
                front of every term of degree congruent to <span
                class="math inline">\(r\)</span> modulo <span
                class="math inline">\(K\)</span> is then precisely our
                answer. Framed in this manner, it is clear that a <a
                href="https://artofproblemsolving.com/community/c1340h1003741_roots_of_unity_filter?srsltid=AfmBOorgYiA0CNB5iDFLlw8qlH_4-cH9AObiDH_90W-7e_ewovLeURhx">roots
                of unity filter</a> would work (using our root <span
                class="math inline">\(\omega\)</span> instead of complex
                numbers, of course). Indeed, unfortunately (as I said
                earlier), I missed this, which is a bit of an oops since
                I really shouldn't have. I think I just got too excited
                seeing something with cyclotomic integers because I was
                thinking about them a little bit earlier (I might make a
                blog post later about how you can efficiently implement
                them with SIMD, but we'll see).</p>
                <p>Fortunately, by viewing this as a slightly harder
                problem, I learned a lot more! I viewed the problem as
                evaluating <span class="math inline">\(f(X)\)</span>
                over the ring <span class="math inline">\(\mathbf{Z}_M
                [X]/(X^K - 1)\)</span>.</p>
                <p>In other words, we can treat our polynomial as an
                array <span class="math inline">\(f[i]\)</span>, where
                <span class="math inline">\(f(x) = \sum_{i = 0}^{K-1}
                f[i] \omega^i\)</span>, where <span
                class="math inline">\(\omega\)</span> is a <span
                class="math inline">\(K\)</span>th root of unity once
                again. It then suffices to figure out how to quickly
                multiply these polynomials modulo <span
                class="math inline">\(X^K - 1\)</span> while keeping the
                coefficients modulo <span
                class="math inline">\(M\)</span>. Once we have the
                multiplied polynomials, it suffices to just output the
                constant term as the answer. How shall we do this
                polynomial multiplication? We'll do this how any other
                fast polynomial multiplication algorithm works: the fast
                Fourier transform!</p>
                <h2 id="the-algorithm">The Algorithm</h2>
                <p>As at the start of the problem, we separated it into
                two parts based on some assumption for ease of cognitive
                load and clarity. Let's do this again! I'm going to
                outline what the algorithm is for finding an answer so
                the reader can</p>
                <ol type="1">
                <li>Recap what we've gone through, and</li>
                <li>See how everything fits together so that the
                transform is the only remaining key piece we need to
                figure out.</li>
                </ol>
                <p>So, let's go through our algorithm!</p>
                <ol type="1">
                <li>First, we can find a primitive root <span
                class="math inline">\(\zeta\)</span> modulo <span
                class="math inline">\(M\)</span> and then set <span
                class="math inline">\(\omega := \zeta^{(M-1)/K}\)</span>
                to get a <span class="math inline">\(K\)</span>th root
                of unity modulo <span
                class="math inline">\(M\)</span>.</li>
                <li>Next, we can factorize <span class="math inline">\(N
                \bigstar = p_1^{e_1} \cdots p_\ell^{e_\ell}\)</span>
                using some prefix sums.</li>
                <li>For each <span class="math inline">\(i \in \{1,
                \ldots, \ell \}\)</span> do the following:
                <ul>
                <li><p>Let <span class="math inline">\(a[i][j]\)</span>
                be an array (indexed by <span class="math inline">\(0
                \le j &lt; K\)</span>) such that <span
                class="math display">\[
                  a[i][j] = p_i^{j} + p_i^{j + K} + \cdots + p^{j + T K}
                \bmod{M}
                ,\]</span> where <span class="math inline">\(T =
                \left\lfloor \frac{e_i - j}{K} \right\rfloor\)</span>.
                Equivalently, <span class="math display">\[
                  a[i][j] = p_i^j \frac{p_i^{(T+1)K} - 1}{p_i^K - 1}
                \bmod{M}
                .\]</span></p></li>
                <li><p>Compute <span class="math inline">\(\hat{a}[i] =
                \textsf{NTT}([a[i][0], \ldots, a[i][K-1]],
                \omega)\)</span></p></li>
                </ul></li>
                <li>Compute <span class="math inline">\(\hat{d}[j] =
                \hat{a}[1][j] \times \hat{a}[2][j] \times \cdots \times
                \hat{a}[\ell][j]\)</span>.</li>
                <li>Compute <span class="math inline">\(d =
                \textsf{INTT}(\hat{d}, \omega)\)</span></li>
                <li>Output <span
                class="math inline">\(d[0]\)</span>.</li>
                </ol>
                <p>Indeed, we using the NTT (<a
                href="https://mathworld.wolfram.com/NumberTheoreticTransform.html">number-theoretic
                transform</a>) to efficiently multiply polynomials over
                our ring. Another way to intuit our algorithm is that we
                are utilizing the <a
                href="https://en.wikipedia.org/wiki/Convolution_theorem">convolution
                theorem</a>. If you notice, this algorithm actually
                gives us the answer to <span
                class="math inline">\(D(N\bigstar, K, r)\)</span>
                (contained in array <span
                class="math inline">\(d\)</span>) for all <span
                class="math inline">\(r\)</span> all at once. That's why
                this solution is probably a little bit more overkill
                than using a simple roots of unity sieve.</p>
                <p>Now, it suffices to figure out what's going on behind
                the transform algorithm itself.</p>
                <h2 id="the-fast-number-theoretic-transform">The (Fast)
                Number-Theoretic Transform</h2>
                <p>We shall now work under <span
                class="math inline">\(\mathbf{F}_p\)</span> so I don't
                have to put congruences everywhere.</p>
                <p>Suppose <span class="math inline">\(x \in
                \mathbf{F}_p^L\)</span> is an array of length <span
                class="math inline">\(L\)</span> and <span
                class="math inline">\(\omega \in \mathbf{F}_p\)</span>
                is an <span class="math inline">\(L\)</span>th root of
                unity. We wish to find its number-theoretic transform,
                <span class="math inline">\(\hat{x}\)</span>, which is
                the array such that <span class="math display">\[
                    \textsf{NTT}(x, \omega) := \hat{x}[k] = \sum_{i =
                0}^{L - 1} x[i] \omega^{ik}
                .\]</span> But, of course, if we naively evaluate it
                like this, we run into time problems. This would be an
                <span class="math inline">\(O(L^2)\)</span> algorithm!
                We can instead build a fast recursive algorithm.</p>
                <p>For our base case, notice that when <span
                class="math inline">\(L = 1\)</span>, <span
                class="math inline">\(\hat x = x\)</span>. Now, let
                <span class="math inline">\(q\)</span> be the smallest
                prime factor of <span class="math inline">\(L\)</span>.
                Since <span class="math inline">\(L &gt; 1\)</span>, we
                have that <span class="math inline">\(q &gt; 1\)</span>.
                We typically call <span class="math inline">\(q\)</span>
                the <em>radix</em> (typically you'll only see radix
                <span class="math inline">\(2\)</span> algorithms
                because people zero pad their arrays until <span
                class="math inline">\(L\)</span> is a power of <span
                class="math inline">\(2\)</span>, but we can't do this
                because it would destroy our answer), because we are
                going to separate the NTT of length <span
                class="math inline">\(L\)</span> into <span
                class="math inline">\(q\)</span> NTTs of length <span
                class="math inline">\(\ell := L / q\)</span>.</p>
                <p>For <span class="math inline">\(r \in \{0, 1, \ldots,
                q - 1 \}\)</span>, let <span class="math display">\[
                    x_r = \bigl[x[r], x[q + r], \ldots, x[q (\ell - 1) +
                r] \bigr]
                ,\]</span> so that <span
                class="math inline">\(x_r\)</span> is an array of length
                <span class="math inline">\(\ell\)</span> of all the
                coefficients with indices that are congruent to <span
                class="math inline">\(r\)</span> mod <span
                class="math inline">\(q\)</span>. Moreover, compute
                <span class="math inline">\(\hat{x}_r =
                \textsf{NTT}(x_r, \omega^q)\)</span> (as <span
                class="math inline">\(\omega^q\)</span> is an <span
                class="math inline">\(\ell\)</span>th root of unity),
                their number-theoretic transforms.</p>
                <p>Now comes the key insight. Observe that <span
                class="math display">\[\begin{align*}
                    \hat{x}[k] &amp;= \sum_{i = 0}^{\ell q - 1} x[i]
                \omega^{ik} \\
                    &amp;= \sum_{r = 0}^{q - 1} \sum_{j = 0}^{\ell - 1}
                x[qj + r] \omega^{(qj + r)k}
                    \\
                    &amp;= \sum_{r = 0}^{q - 1} \omega^{rk} \sum_{j =
                0}^{\ell - 1} x[qj + r] \left( \omega^q \right)^{jk} \\
                    &amp;= \sum_{r = 0}^{q - 1} \omega^{rk} \hat{x}_r[k]
                .\end{align*}\]</span> We can calculate the NTT of <span
                class="math inline">\(x\)</span> efficiently using the
                sub-NTTs (fun fact: the <span
                class="math inline">\(\omega^{rk}\)</span> coefficients
                are usually called twiddle factors)!</p>
                <p>Now, let's look at the time complexity. At each
                recursive level of the NTT, there are <span
                class="math inline">\(t\)</span> calls of with arrays of
                length <span class="math inline">\(L / t\)</span>. At
                each call, we iterate over the array of length <span
                class="math inline">\(L / t\)</span> perform <span
                class="math inline">\(q\)</span> operations with the
                twiddle factors. For our purposes, <span
                class="math inline">\(q\)</span> is small enough to be
                constant (<span class="math inline">\(K\)</span> in our
                case is <span class="math inline">\(2^3 5^3\)</span> so
                <span class="math inline">\(q \in \{2, 5 \}\)</span>),
                so one level of calls is just <span
                class="math inline">\(O(L)\)</span> time. Since we
                divide by a prime factor each time, there are at most
                <span class="math inline">\(O(\log L)\)</span> levels.
                Thus, the time complexity is <span
                class="math inline">\(O(L \log L)\)</span>, which is the
                desired faster speedup compared to <span
                class="math inline">\(O(L^2)\)</span> naively.</p>
                <p>Inverting the NTT is just a case of applying the NTT
                with <span class="math inline">\(\omega^{-1}\)</span>
                and then dividing each coefficient by <span
                class="math inline">\(L\)</span>. There's not much to
                say there. Thus, we've completed the necessary steps to
                finish the problem.</p>
                <p>Yippee!</p>
                <h2 id="conclusions">Conclusions</h2>
                <p>While I tried to give good exposition, motivation,
                and background for the techniques used in this problem,
                I couldn't explain everything in a self-contained
                manner. In fact, doing so would probably give me a big
                headache! However, I encourage the reader to look up and
                read in more depth some of the number-theoretic or
                algebraic notions mentioned in this writeup. These are
                some really beautiful results that, used together, solve
                problems an efficient, elegant manner. That being said,
                it is also partly my fault. I think I'm rusty! This
                isn't so surprising given the long break, but it's
                another piece of motivation for me to get better at
                explaining ideas. I'm definitely going to look towards
                more visuals soon (hopefully maybe it'll be really cool
                I just need to figure out like all of OpenGL and lots of
                numerics).</p>
                <p>ALSO! Look out for more articles in the future!
                There's a bunch of stuff I want to cover, and I'm
                praying to everything that I don't get swamped with
                homework that stops me from writing. Thank you for
                reading, and if you skimmed down here, thank you for
                skimming too (now go back and read) (bring those average
                literacy rates up buckaroo).</p>
            </div>
        </div>
    </body>
</html>
